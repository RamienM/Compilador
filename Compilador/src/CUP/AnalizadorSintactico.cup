package CUP;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

import java_cup.runtime.*;

import Symbols.*;
import CUP.*;

import java.io.PrintStream;
import java.util.HashMap;

class Parser;

parser code {:
    private HashMap<String, Integer>tsymbolsI = new HashMap<>();
    private HashMap<String, Boolean>tsymbolsB = new HashMap<>();

    public int getSymbolValueInteger(String id){
        return (int)tsymbolsI.get(id);
    }
    public boolean getSymbolValueBoolean(String id){
        return (boolean)tsymbolsB.get(id);
    }
    
    public boolean estaInteger(String id){
        return tsymbolsI.containsKey(id);
    }
    public boolean estaBoolean(String id){
        return tsymbolsB.containsKey(id);
    }

    public void addSymbol(String id, int value){
        if(tsymbolsI.get(id) == null){
            tsymbolsI.put(id,value);
        } else{
            tsymbolsI.replace(id,value);
        }
    }
    public void addSymbol(String id, boolean value){
        if(tsymbolsB.get(id) == null){
            tsymbolsB.put(id,value);
        } else{
            tsymbolsB.replace(id,value);
        }
    }
    
    public void printVars(PrintStream out) {
        if (tsymbolsI.size() == 0) {
            out.println("No hi ha variables enteras declarades");
        } else {
            String fmt = "%-8s: %d";
            tsymbolsI.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
        if (tsymbolsB.size() == 0) {
            out.println("No hi ha variables booleanas declarades");
        } else {
            String fmt = "%-8s: %b";
            tsymbolsB.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
    }

    /**
    * Nos permite saber si se ha detectado un error:
    *   -true: Se ha detectado error
    *   -false: No se ha detectado error
    * En caso de true el funcionamiento será limitado hasta finalizar de procesar
    * la entrada, caso donde lo vuelve a poner a false.
    **/
    private boolean errorSemantic = false;
    
    /*
        -------------------GESTION DE ERRORES---------------------------
    */

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception{
        report_error("Error sintactico irrecuperable", cur_token);
        done_parsing();
    }

    @Override
    public void syntax_error(Symbol cur_token){
        report_error("de sintaxis", cur_token);
    }
    
    @Override
    public void report_error(String message, Object info){
        StringBuilder msg = new StringBuilder("ERROR:");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol) info;
            Location l = token.getLeft();

            if(l != null){
                msg.append(" (fila: " + l.getLine() + ", columna: " + l.getColumn() + ")");
            }
        }
        msg.append(": " + message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception{
        report_error("Error irrecuperable (" + message + ")", info);
        done_parsing();
    }
    
:}


terminal String IDENTIFICADOR;
terminal int valor;

//Terminales de operaciones aritméticas
terminal SUMA, RESTA, MULTIPLICACION, DIVISION, MODULO;
//Terminales de operaciones relacionales
terminal EQUIVALENTE, MENORIGUAL, MAYORIGUAL, MAYOR, MENOR, NOEQUIVALENTE;
//Terminales de operaciones lógicas
terminal AND, OR, XOR, NOT;
//Parentesis, llaves y asignacion
terminal LPARENTESIS, RPARENTESIS, LLLAVE, RLLAVE, ASIGNACION;
//Puntos y comas
terminal PUNTOCOMA, COMA, PUNTO;
//Condicionales
terminal IF, ELSE;
//Bucles
terminal WHILE, DO, FOR;
//Palabras reservadas
terminal RETURN, MAIN, INT, BOOL, PROC, FUNT, BREAK, PRINT, PRINTLN, ENTER, ENTERLN,CONST;

non terminal Bloque;
non terminal BloqueP;

non terminal Procedimiento;
non terminal Funcion;
non terminal Main;

non terminal Atributos;
non terminal AtributosP;

non terminal Instrucciones;

non terminal Datos;


non terminal Condicionales;
non terminal Bucles;
non terminal While;
non terminal Do;
non terminal Returns;

non terminal Asignaciones;
//non terminal AsignacionesP;

non terminal SymbolID ID;

non terminal Else;

non terminal SymbolExpresiones Expresiones;
non terminal SymbolExpresionesP ExpresionesP;
non terminal SymbolExpresionesC ExpresionesC;
non terminal SymbolExpresionesCP ExpresionesCP;
non terminal SymbolExp Exp;

non terminal SymbolOperacionesAritmeticas OperacionesAritmeticas;
non terminal SymbolOperacionesAritmeticasP OperacionesAritmeticasP;
non terminal SymbolMultiplicacionDivision MultiplicacionDivision;
non terminal SymbolMultiplicacionDivisionP MultiplicacionDivisionP;
non terminal SymbolFinalOperaciones FinalOperaciones;



precedence right ASIGNACION; 
precedence left  SUMA, RESTA, MULTIPLICACION, DIVISION, MODULO;
precedence left  EQUIVALENTE, NOEQUIVALENTE, MAYORIGUAL, MAYOR, MENORIGUAL, MENOR, AND, OR, XOR, NOT;

start with Bloque;

Bloque ::= 
    BloqueP Bloque   
            {::}
    | 
            {::} 
        ;

BloqueP ::= 
    Procedimiento   
            {::}
    | Funcion       
            {::}
    | Main             
            {::}
        ;

Procedimiento ::= 
    PROC IDENTIFICADOR LPARENTESIS Atributos RPARENTESIS LLLAVE Instrucciones RLLAVE  
            {::}
        ;

Funcion ::= 
    FUNT IDENTIFICADOR LPARENTESIS Atributos RPARENTESIS LLLAVE Instrucciones RLLAVE  
            {::}
        ;

Atributos ::= 
    Datos IDENTIFICADOR AtributosP    
            {::}
        ;

AtributosP ::= 
    COMA Atributos   
            {::}
    |   
            {::}
        ;

Main ::= 
    MAIN LLLAVE Instrucciones RLLAVE   
            {::}
        ;

Instrucciones ::= 
    Asignaciones Instrucciones
            {::}
    | Condicionales Instrucciones
            {::}
    | Bucles Instrucciones       
            {::}
    | Returns Instrucciones      
            {::}
    | 
            {::} 
        ;

Asignaciones ::= 
    INT IDENTIFICADOR:v1 ASIGNACION OperacionesAritmeticas:v2 PUNTOCOMA  
            {:
                addSymbol(v1,(int)v2.value); 
            :}
    |BOOL IDENTIFICADOR:v1 ASIGNACION Expresiones:v2 PUNTOCOMA  
            {:
                addSymbol(v1,(boolean)v2.value); 
            :}
    //|IDENTIFICADOR:v1 ASIGNACION AsignacionesP:v2 PUNTOCOMA       
    //        {:
    //            addSymbol(v1,(int)v2.value); 
    //        :}
        ;

Condicionales ::= 
    IF LPARENTESIS Expresiones RPARENTESIS LLLAVE Instrucciones RLLAVE Else   
            {::}
        ;

Else ::= 
    ELSE LLLAVE Instrucciones RLLAVE  
            {::}
    | 
            {::}  
        ;

Bucles ::= 
    While    
            {::}
    |Do    
            {::}
        ;

While ::= 
    WHILE LPARENTESIS Expresiones RPARENTESIS LLLAVE Instrucciones RLLAVE 
            {::}
        ;

Do ::= 
    DO LLLAVE Instrucciones RLLAVE WHILE LPARENTESIS Expresiones RPARENTESIS PUNTOCOMA 
            {::}
        ;

Returns ::= 
    RETURN ID:v PUNTOCOMA 
            {:
                //RESULT = new SymbolReturns(v.value);
            :}
        ;

Datos ::= 
    INT 
            {::}
    | BOOL 
            {::}
        ;

ID ::= 
    IDENTIFICADOR:v 
            {:
                if(estaInteger(v)){
                    int valor = getSymbolValueInteger(v);
                    RESULT = new SymbolID(valor);
                }else if (estaBoolean(v)){
                    boolean valor = getSymbolValueBoolean(v);
                    RESULT = new SymbolID(valor);
                }
            :}
    | valor :v
            {:
                RESULT = new SymbolID(v);
            :}
        ;
Expresiones ::= 
    ExpresionesC:v1 ExpresionesP:v2
            {:
                RESULT = new SymbolExpresiones((boolean)v1.value,v2);
            :}
        ;
ExpresionesP ::=
    AND ExpresionesC:v1 ExpresionesP:v2   
            {:
                RESULT = new SymbolExpresionesP((boolean)v1.value, ParserSym.OR,v2);
            :}
    |OR ExpresionesC:v1 ExpresionesP:v2  
            {:
                RESULT = new SymbolExpresionesP((boolean)v1.value, ParserSym.OR,v2);
            :}
    |XOR ExpresionesC:v1 ExpresionesP:v2   
            {:
                RESULT = new SymbolExpresionesP((boolean)v1.value, ParserSym.XOR,v2);
            :}
    |
            {:
                RESULT = new SymbolExpresionesP();
            :}
        ;

ExpresionesC ::= 
    Exp:v1 ExpresionesCP:v2
            {:
                RESULT = new SymbolExpresionesC(v1,v2);
            :}
        ;

ExpresionesCP ::=
    EQUIVALENTE Exp:v    
            {:
                if(v.value instanceof Boolean){
                    RESULT = new SymbolExpresionesCP((boolean)v.value, ParserSym.EQUIVALENTE);
                }else{
                    RESULT = new SymbolExpresionesCP((int)v.value, ParserSym.EQUIVALENTE);
                }      
            :}
    |NOEQUIVALENTE Exp:v  
            {:
                if(v.value instanceof Boolean){
                    RESULT = new SymbolExpresionesCP((boolean)v.value, ParserSym.NOEQUIVALENTE);
                }else{
                    RESULT = new SymbolExpresionesCP((int)v.value, ParserSym.NOEQUIVALENTE);
                }   
            :}
    |MAYORIGUAL Exp:v    
            {:
                if(v.value instanceof Boolean){
                    System.out.println("Se está intentando pasar un valor booleano cuando se requiere un entero");
                    RESULT = new SymbolExpresionesCP();
                }else{
                    RESULT = new SymbolExpresionesCP((int)v.value, ParserSym.MAYORIGUAL);
                }   
            :}
    |MAYOR Exp:v        
            {:
                if(v.value instanceof Boolean){
                    System.out.println("Se está intentando pasar un valor booleano cuando se requiere un entero");
                    RESULT = new SymbolExpresionesCP();
                }else{
                    RESULT = new SymbolExpresionesCP((int)v.value, ParserSym.MAYOR);
                } 
            :}
    |MENORIGUAL Exp:v    
            {:
                if(v.value instanceof Boolean){
                    System.out.println("Se está intentando pasar un valor booleano cuando se requiere un entero");
                    RESULT = new SymbolExpresionesCP();
                }else{
                    RESULT = new SymbolExpresionesCP((int)v.value, ParserSym.MENORIGUAL);
                } 
            :}
    |MENOR Exp:v      
            {:
                if(v.value instanceof Boolean){
                    System.out.println("Se está intentando pasar un valor booleano cuando se requiere un entero");
                    RESULT = new SymbolExpresionesCP();
                }else{
                    RESULT = new SymbolExpresionesCP((int)v.value, ParserSym.MENOR);
                } 
            :}
    |
            {:
                RESULT = new SymbolExpresionesCP();
            :}
        ;


OperacionesAritmeticas::= 
    MultiplicacionDivision:v1 OperacionesAritmeticasP:v2    
            {:
                RESULT = new SymbolOperacionesAritmeticas((int)v1.value, v2);
            :}
        ;

OperacionesAritmeticasP::= 
    SUMA MultiplicacionDivision:v1 OperacionesAritmeticasP:v2      
            {:
                RESULT = new SymbolOperacionesAritmeticasP(ParserSym.SUMA,(int)v1.value, v2);
            :}
    |RESTA MultiplicacionDivision:v1 OperacionesAritmeticasP:v2  
            {:
                RESULT = new SymbolOperacionesAritmeticasP(ParserSym.RESTA,(int)v1.value, v2);
            :}
    |
            {:
                RESULT = new SymbolOperacionesAritmeticasP();
            :}
        ;

MultiplicacionDivision::= 
    FinalOperaciones:v1 MultiplicacionDivisionP:v2  
            {:
                RESULT = new SymbolMultiplicacionDivision((int)v1.value, v2);
            :}
        ;

MultiplicacionDivisionP ::= 
    MULTIPLICACION FinalOperaciones:v1 MultiplicacionDivisionP:v2 
            {:
                RESULT = new SymbolMultiplicacionDivisionP(ParserSym.MULTIPLICACION,(int)v1.value, v2);
            :}
    |DIVISION FinalOperaciones:v1 MultiplicacionDivisionP:v2      
            {:
                RESULT = new SymbolMultiplicacionDivisionP(ParserSym.DIVISION,(int)v1.value, v2);
            :}
    |MODULO FinalOperaciones:v1 MultiplicacionDivisionP:v2        
            {:
                RESULT = new SymbolMultiplicacionDivisionP(ParserSym.MODULO,(int)v1.value, v2);
            :}
    |
            {:
                RESULT = new SymbolMultiplicacionDivisionP();
            :}
        ;


Exp ::= 
    LPARENTESIS Expresiones:v RPARENTESIS      
            {:
                RESULT = new SymbolExp((boolean)v.value);
            :}
    |ID:v                                     
            {:
                RESULT = new SymbolExp(v);
            :}
    |NOT Exp:v                
            {:
                if(v.value instanceof Boolean){
                    RESULT = new SymbolExp((boolean)v.value);
                }else{
                    System.out.println("Se está pasando por parametro un entero cuando debería ser booleano");
                }
            :}
        ;

FinalOperaciones ::=
    LPARENTESIS OperacionesAritmeticas:v RPARENTESIS 
            {:
                RESULT = new SymbolFinalOperaciones((int)v.value);
            :}
    |ID:v
            {:
                if(v.value instanceof Integer){
                    RESULT = new SymbolFinalOperaciones((int)v.value);
                }else{
                    System.out.println("Se está pasando por parametro un Booleano cuando debería ser Integer");
                }
            :}
    |RESTA OperacionesAritmeticas:v
            {:
                RESULT = new SymbolFinalOperaciones(-1 * (int)v.value);
            :}
        ;
    